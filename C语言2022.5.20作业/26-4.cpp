/*4、【程序功能】
在给定的范围内查找并输出所有满足以下条件的整数对（a，b）及与（a，b）关联的反序数对（c，d）：
（1）a小于b：（2）a和b的十进制表示均是三位数且各位上的数字互不相同；
（3）a的反序数（记作c）和b的反序数（记作d）也都是三位数并且a×b等于c×d。
例如，与整数对（302，406）关联的反序数对是（203，604），302×406=203×604，因此（302，406）是满足上述条件的整数对。
【编程要求】
（1）编写函数int find(int x[][4],int m,int n)实现以下功能：若m和n的十进制表示不是三位数则函数返回0。
否则，将取值在[m,n]范围内所有满足上述条件的整数对以及与这些整数对关联的反序数对保存到x指向的二维数组中，
函数返回x数组中保存的数据行数。
（2）编写函数main实现以下功能：声明一个100行4列的二维数组a，用a数组作实参调用find函数在[300,450]范围内查找，
将找到的满足上述条件的整数对及关联的反序数对保存到a数组。按以下格式将a数组中数据输出到屏幕。
【测试数据与运行结果】
输出：
301*309=103*903      302*406=203*604   304*403=403*304    306*402=603*204
312*426=213*624 314*413=413*314 321*369=123*963 324*423=423*324 402*408=204*804  412*428=214*824

*/
#include<stdio.h>
int rev(int num)
{
	int n=0;
	while(num)
	{
		n=n*10+num%10;
		num/=10;
	}
	
	return n;
}
bool Isfun(int num)
{
	int a[10]={0},sign=0;
	while(num)
	{
		a[num%10]++;
		num/=10;
	}
	
	for(int i=0;i<10;i++)
		if(a[i])	sign++;
	if(sign==3)	return true;
	return false;
}
int find(int x[][4],int m,int n)
{
	int i,j,k=0;
	for(i=m;i<=n;i++)
		for(j=i+1;j<=n;j++)
			if(Isfun(i)&&Isfun(j)&&i*j==rev(i)*rev(j))
			{
				x[k][0]=i;
				x[k][1]=j;
				x[k][2]=rev(i);
				x[k++][3]=rev(j);
			}
	printf("***%5d\n",k);
	return k;
}
main()
{
	int a[100][4];
	int i,num,m=300,n=450;
	num=find(a,m,n);
	for(i=0;i<num;i++)
	{
		printf("%5d*%5d = %5d*%5d\n",a[i][0],a[i][1],a[i][2],a[i][3]);
	}
}

